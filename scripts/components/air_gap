#!/usr/bin/env bash
# shellcheck disable=SC1091,SC2086,SC1001,SC2317,SC2120
# shellcheck source="$HOME/.bashrc"

create_airgap_script(){
  cat > $NODE_HOME/airgap_script << EOF
#!/bin/bash
# shellcheck disable=SC1091,SC2086,SC1001,SC2317
# shellcheck source="\$HOME/.bashrc"

clear
script_title="${1}"

RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\e[36m'
PURPLE='\e[35m'
YELLOW='\e[33m'
BLUE='\e[34m'
WHITE='\e[37m'
BOLD='\e[1m'
UNDERLINE='\e[4m'
NC='\033[0m' # No Color


yes_no(){
  while :
      do
        read -r -n 1 select_number < /dev/tty
          case \${select_number} in
            1) return 0 ;;                              # Yes
            2) echo "スクリプトを終了します" > /dev/tty; return 1 ;;  # No
            *) echo "1 か 2 を入力してください" > /dev/tty ;;
          esac
    done
}

Verify(){
  echo
  echo "BPに表示されているairgap-set.tar.gzのハッシュを確認してください"
  hash_value=\$(sha256sum \${NODE_HOME}/airgap-set.tar.gz | awk '{print \$1}')
  echo -e "ハッシュ値：\${YELLOW}\${hash_value}\${NC}"
  echo
  echo "上記のハッシュ値をBPに表示されてるハッシュ値と照合してください"
  echo
  echo "[1] 一致する [2] 一致しない"

  if yes_no; then
      echo
      echo "\${script_title}処理を実行しますか？"
      echo "[1] はい [2] いいえ"

      if yes_no; then
          tar -xzf \${NODE_HOME}/airgap-set.tar.gz --exclude="airgap_script" -C \${NODE_HOME}
          if [ \$? -ne 0 ]; then
              echo -e "\${RED}airgap-set.tar.gzの解凍に失敗しました。\${NC}"
              rm \${NODE_HOME}/airgap_script
              exit 1
          fi
          return 0   # 正常終了で関数を抜ける
      else
          echo "処理をキャンセルしました。"
          exit 0
      fi
  else
      echo "再度BPからairgap-set.tar.gzをコピーしてください"
      sleep 2
      exit 1
  fi
}

case \$1 in
  "verify" )
    Verify
  ;;

  "*" )
    echo "不正な引数です"
    rm \${NODE_HOME}/airgap_script
    exit 0
  ;;
esac

#------------------------------------------

EOF
}


signing_tx_file(){
  case $1 in
    "pool_register" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} --signing-key-file ${COLDKEYS_DIR}/${COLD_SKEY_FILENAME} --signing-key-file \${NODE_HOME}/${STAKE_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
    "stake_address" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} --signing-key-file \${NODE_HOME}/${STAKE_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
    "payment_address" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
  esac
  cat >> "${NODE_HOME}/airgap_script" <<EOF
PAYMENT_ADDR_FILE="${PAYMENT_ADDR_FILENAME}"
EOF
  cat >> "${NODE_HOME}/airgap_script" <<'EOF'
echo
echo "tx.rawをデコードして処理内容を確認します"
decode_tmp=$(mktemp)
decode_log=$(mktemp)

if ! cardano-cli debug transaction view --tx-body-file ${NODE_HOME}/tx.raw > "${decode_tmp}" 2> "${decode_log}"; then
  echo -e "${RED}tx.rawのデコードに失敗しました${NC}"
  cat "${decode_log}"
  rm -f "${decode_log}" "${decode_tmp}"
  rm -f ${NODE_HOME}/airgap_script
  exit 1
fi
rm -f "${decode_log}"

payment_addr=""
if [[ -f "${NODE_HOME}/${PAYMENT_ADDR_FILE}" ]]; then
  payment_addr=$(tr -d ' \t\r\n' < "${NODE_HOME}/${PAYMENT_ADDR_FILE}")
fi

summary_json=""
if command -v jq >/dev/null 2>&1; then
  summary_json=$(jq -c --arg myaddr "${payment_addr}" '
    def lovelace_amount($value):
      if $value == null then 0
      elif ($value | type) == "number" then $value
      elif ($value | type) == "string" then
        (( ($value | split(" ")[0]) | tonumber? ) // 0)
      elif ($value | type) == "object" then
        ($value.lovelace // $value.coin // $value.amount // ($value.ada?.lovelace) // ($value.contents? | lovelace_amount(.)) // 0)
      else 0
      end;

    def normalize_outputs:
      (.outputs // [])
      | map({
          address: (.address // .addressShelley // .addressBech32 // .value.address // ""),
          lovelace: lovelace_amount(.amount // .value)
        })
      | map(select(.address != ""))
      | (if $myaddr != "" then
           map(select(.address != $myaddr))
         else
           (if length > 1 then .[1:] else [] end)
         end);

    def normalize_withdrawals:
      if (.withdrawals // null) == null then []
      elif (.withdrawals | type) == "object" then
        (.withdrawals | to_entries | map({address: .key, lovelace: lovelace_amount(.value)}))
      elif (.withdrawals | type) == "array" then
        (.withdrawals | map({address: (.address // .stake_address // .stake // ""), lovelace: lovelace_amount(.amount // .value)}))
      else []
      end;

    def first_certificate:
      (.certificates // [])
      | map(select(type == "object"))
      | map(keys_unsorted[0])
      | .[0];

    {
      fee: lovelace_amount(.fee),
      certificate: first_certificate,
      withdrawals: normalize_withdrawals,
      outputs: normalize_outputs
    }
  ' "${decode_tmp}" 2>/dev/null)
  if [[ "${summary_json}" == "null" ]]; then
    summary_json=""
  fi
fi

echo
echo "payment.addr: ${payment_addr:-N/A}"
if command -v jq >/dev/null 2>&1; then
  if jq '(.certificates // null) != null' "${decode_tmp}" >/dev/null 2>&1; then
    echo "tx.raw certificates (raw):"
    jq '.certificates' "${decode_tmp}" 2>/dev/null  || echo "(certificates取得に失敗)"
  else
    echo "tx.raw outputs (raw):"
    jq '.outputs | map({address, amount})' "${decode_tmp}" 2>/dev/null || echo "(outputs取得に失敗)"
  fi
else
  echo "tx.raw outputs (raw):"
  sed -n '/"outputs":/,/]/p' "${decode_tmp}"
fi

echo
echo "------ トランザクション内容 ------"
if [[ -n "${summary_json}" && "${summary_json}" != "{}" ]]; then
  operation_label="payment.addr出金"
  certificate_name=$(echo "${summary_json}" | jq -r '.certificate // empty')
  withdrawals_count=$(echo "${summary_json}" | jq -r '.withdrawals // [] | length')
  outputs_count=$(echo "${summary_json}" | jq -r '.outputs // [] | length')
  fee_value=$(echo "${summary_json}" | jq -r '.fee // empty')
  fee_ada=""
  if [[ -n "${fee_value}" && "${fee_value}" != "0" ]]; then
    fee_ada=$(awk -v val="${fee_value}" 'BEGIN { printf "%.6f", val / 1000000 }')
  fi

  if [[ ${withdrawals_count} -gt 0 ]]; then
    operation_label="ステークアドレス出金"
  elif [[ -n "${certificate_name}" ]]; then
    case "${certificate_name}" in
      "Stake address registration")
        operation_label="ステークアドレス登録"
        ;;
      "Stake address deregistration")
        operation_label="ステークアドレス解除"
        ;;
      "Pool registration")
        operation_label="プール登録/情報変更"
        ;;
      "Pool retirement")
        operation_label="プールリタイア"
        ;;
      *)
        operation_label="証明付きトランザクション"
        ;;
    esac
  fi

  echo "処理内容: ${operation_label}"
  echo
  if [[ ${withdrawals_count} -gt 0 ]]; then
    while IFS=$'\t' read -r stake_addr stake_lovelace; do
      [[ -z "${stake_addr}" ]] && continue
      stake_ada=$(awk -v val="${stake_lovelace}" 'BEGIN { printf "%.6f", val / 1000000 }')
      echo -e "出金先: ${GREEN}${stake_addr}${NC}"
      echo -e "出金額: ${GREEN}${stake_ada}${NC} ADA (${stake_lovelace} Lovelace)"
      echo
    done < <(echo "${summary_json}" | jq -r '
      (.withdrawals // [])
      | map("\(.address)\t\(.lovelace)")
      | .[]
    ')
  elif [[ "${operation_label}" == "payment.addr出金" && ${outputs_count} -gt 0 ]]; then
    while IFS=$'\t' read -r out_addr out_lovelace; do
      [[ -z "${out_addr}" ]] && continue
      out_ada=$(awk -v val="${out_lovelace}" 'BEGIN { printf "%.6f", val / 1000000 }')
      echo -e "送金先: ${GREEN}${out_addr}${NC}"
      echo -e "送金額: ${GREEN}${out_ada}${NC} ADA (${out_lovelace} Lovelace)"
    done < <(echo "${summary_json}" | jq -r '
      (.outputs // [])
      | map("\(.address)\t\(.lovelace)")
      | .[]
    ')
  elif [[ -n "${certificate_name}" ]]; then
    echo "証明タイプ: ${certificate_name}"
  fi

  if [[ -n "${fee_value}" && "${fee_value}" != "0" ]]; then
    echo -e "手数料: ${GREEN}${fee_ada}${NC} ADA (${fee_value} Lovelace)"
  fi
else
  if command -v jq >/dev/null 2>&1; then
    jq '. | {fee, certificates, withdrawals, outputs}' "${decode_tmp}" || cat "${decode_tmp}"
  else
    cat "${decode_tmp}"
  fi
fi
echo "--------------------------------"

echo "この内容で署名しますか？ [1] はい [2] いいえ"

if ! yes_no; then
  echo "署名をキャンセルしました"
  rm -f "${decode_tmp}"
  rm -f ${NODE_HOME}/airgap_script
  exit 0
fi

rm -f "${decode_tmp}"
EOF
  cat >> "${NODE_HOME}/airgap_script" << EOF 
$sing_cli
echo
echo "トランザクション署名ファイルを生成しました(\${NODE_HOME}/tx.signed)"
echo
echo -e "\${GREEN}tx.signed\${NC}をBPの作業ディレクトリにコピーしてください"
hash_value=\$(sha256sum \${NODE_HOME}/tx.signed | awk '{print \$1}')
echo -e "ハッシュ値：\${YELLOW}\${hash_value}\${NC}"
echo
read -p "コピーしたらEnterを押して下さい" < /dev/tty
rm -f \${NODE_HOME}/airgap_script
EOF
chmod 755 ${NODE_HOME}/airgap_script
}


CreatePoolCert(){
  source ${env_path}
  local -a relayHosts relayPorts
  local existingRelayCount=0
  local key value idx
  local existingRelayAddress existingRelayPort
  local hasRelayPortEntries=0

  if [[ -f "${env_path}" ]]; then
    while IFS='=' read -r key value; do
      value=${value%$'\r'}
      if [[ $key =~ ^RELAY([0-9]+)_HOST$ ]]; then
        idx=${BASH_REMATCH[1]}
        relayHosts[$idx]="${value}"
      elif [[ $key =~ ^RELAY([0-9]+)_PORT$ ]]; then
        idx=${BASH_REMATCH[1]}
        relayPorts[$idx]="${value}"
        hasRelayPortEntries=1
      fi
    done < "${env_path}"

    for idx in "${!relayHosts[@]}"; do
      if [[ -n "${relayHosts[$idx]}" ]]; then
        ((existingRelayCount++))
      fi
    done
  fi

  local defaultRelayNum="${existingRelayCount}"
  if [[ ${hasRelayPortEntries} -eq 0 ]]; then
    defaultRelayNum="2"
  fi
  while :
  do
  inputPledge=$(gum input --width=0 --header="Pledge誓約ADAを整数で入力して下さい(例:10000)" --char-limit=7 --header.foreground="99" --no-show-help --placeholder "Pledge")
  if [[ "$inputPledge" =~ ^[0-9]+$ ]]; then
    if (( "$inputPledge" >= 1 )); then
      break 1
    else
      echo "1以上の数字を入力してください"
    fi
  else
    echo "数字を入力してください"
  fi
  done
  inputFixCost=$(gum input --value="170" --width=0 --header="固定手数料を整数で入力してください(170以上)" --char-limit=5 --header.foreground="99" --no-show-help --placeholder "Fix Cost")
  inputFixMargin=$(gum input --value="0.5" --width=0 --header="変動手数料率を入力してください(%不要)" --char-limit=3 --header.foreground="99" --no-show-help --placeholder "0.5 or 1.5 or 3 etc...")

  while :
  do
    inputRelayNum=$(gum input --value="${defaultRelayNum}" --width=0 --header="オンチェーンに登録するリレー数を入力してください" --char-limit=1 --header.foreground="99" --no-show-help --placeholder "Number Of Relay")
      # 入力が数字かどうかを確認
    if [[ "$inputRelayNum" =~ ^[0-9]+$ ]]; then
      # 配列を使用して変数を管理
      declare -a inputRelays=()
      declare -a inputPorts=()
      poolRelaySet=""

      # ループを実行
      for ((i = 1; i <= $inputRelayNum; i++)); do
        if [ "$i" -ge "2" ]; then poolRelaySet+="   "; fi
        
        

        while :
        do
          existingRelayAddress="${relayHosts[$i]}"
          inputRelayAddress=$(gum input --value="${existingRelayAddress}" --width=0 --header="リレー${i}のIPまたはDNSアドレスを入力してください" --char-limit=255 --header.foreground="99" --no-show-help --placeholder "IP Address or DNS Name")
          # 正規表現でIPv4アドレスの形式をチェック
          if [[ $inputRelayAddress =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
              # 各オクテットが0〜255の範囲内であることをチェック
              IFS='.' read -r -a octets <<< "$inputRelayAddress"
              valid=true
              for octet in "${octets[@]}"; do
                  if (( octet < 0 || octet > 255 )); then
                      valid=false
                      break
                  fi
              done
              if [ "$valid" = true ]; then
                  poolRelaySet+="--pool-relay-ipv4 ${inputRelayAddress}"
                  inputRelays[$i]=${inputRelayAddress}
                  break 1
              else
                  echo "無効なIPアドレスです"
              fi
          elif [[ $inputRelayAddress =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]; then
              poolRelaySet+="--single-host-pool-relay ${inputRelayAddress}"
              inputRelays[$i]=${inputRelayAddress}
              break 1
          else
              echo "無効なIPアドレスまたはDNSアドレスです"
          fi
        done

        while :
        do
        existingRelayPort="${relayPorts[$i]}"
        inputRelayPort=$(gum input --value="${existingRelayPort}" --width=0 --header="リレー${i}のポート番号を入力してください" --char-limit=255 --header.foreground="99" --no-show-help --placeholder "Realy Port")
        if [[ "$inputRelayPort" =~ ^([0-9]{1,5})$ ]]; then
          if (( inputRelayPort >= 1 && inputRelayPort <= 65535 )); then
          poolRelaySet+="   --pool-relay-port ${inputRelayPort}"
          inputPorts[$i]=${inputRelayPort}
          break 1
          else
            echo "1から65535の間の数字を入力してください"
          fi
        else
            echo "入力のポート番号が無効な形式です"
        fi
        done
        


      done
      break 1
    else
      echo "数字を入力してください"
      exit 1
    fi
  done


  # ヘッダー行を出力
  echo -e "誓約(Pledge)" ${B_YELLOW}"${inputPledge}ADA"${NC} >> table.out
  echo -e "固定手数料" "${inputFixCost}ADA"  >> table.out
  echo -e "変動手数料" "${inputFixMargin}%" >> table.out
  echo -e "登録リレー数" "$inputRelayNum"  >> table.out

  for ((i = 1; i <= $inputRelayNum; i++)); do
    echo -e "リレー$iアドレス" "${inputRelays[$i]}"  >> table.out
    echo -e "リレー$iポート" "${inputPorts[$i]}"  >> table.out
  done
  echo -e "メタデータURL" "${POOL_METADATA_URL}"  >> table.out
  column -t < table.out
  rm table.out

  echo
  echo "pool.cert生成実行コマンド確認"
  echo "コマンド上の入力数字はLovelace形式です"
  cmdPoolCert=$(cat << EOF
  cardano-cli conway stake-pool registration-certificate \
    --cold-verification-key-file ${COLDKEYS_DIR}/${COLD_VKEY_FILENAME} \
    --vrf-verification-key-file \${NODE_HOME}/${VRF_VKEY_FILENAME} \
    --pool-pledge $(echo "${inputPledge}000000") \
    --pool-cost $(echo "${inputFixCost}000000") \
    --pool-margin $(echo 0)$(echo "scale=3; ${inputFixMargin} / 100" | bc) \
    --pool-reward-account-verification-key-file \${NODE_HOME}/${STAKE_VKEY_FILENAME} \
    --pool-owner-stake-verification-key-file \${NODE_HOME}/${STAKE_VKEY_FILENAME} \
    $NODE_NETWORK \
    $poolRelaySet \
    --metadata-url ${POOL_METADATA_URL} \
    --metadata-hash \$(cat \${NODE_HOME}/poolMetaDataHash.txt) \
    --out-file \${NODE_HOME}/${POOL_CERT_FILENAME}
EOF
)
  echo
  echo -e ${GRAY}"$cmdPoolCert"${NC} | sed 's/   / \\\n/g'
  echo
  Gum_Confirm_YesNo "この値で${POOL_CERT_FILENAME}を生成しますか？" "Yes" "再度入力してください"
  if [[ ${iniSettings} == "Yes" ]]; then
    script_discription=$(cat <<EOF
このスクリプトでは以下の処理が実行されます
1.プール登録証明書 \${GREEN}${POOL_CERT_FILENAME}\${NC} の作成
2.トランザクション署名ファイル \${GREEN}tx.signed\${NC} の作成
EOF
    )
    create_airgap_script "プール登録証明書作成" "${script_discription}"
    cat >> "${NODE_HOME}/airgap_script" << EOF
    echo
    chmod u+rwx ${COLDKEYS_DIR}
    $cmdPoolCert
    echo -e プール登録証明書 \${YELLOW}"\${NODE_HOME}/${POOL_CERT_FILENAME}\${NC} を生成しました"
EOF
    return
  else
    echo ${iniSettings}
    return 99
  fi

}
