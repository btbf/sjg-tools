#!/usr/bin/env bash
# shellcheck disable=SC1091,SC2086,SC1001,SC2317,SC2120
# shellcheck source="$HOME/.bashrc"

create_airgap_script(){
  cat > $NODE_HOME/airgap_script << EOF
#!/bin/bash
# shellcheck disable=SC1091,SC2086,SC1001,SC2317
# shellcheck source="\$HOME/.bashrc"

clear
script_title="${1}"

RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\e[36m'
PURPLE='\e[35m'
YELLOW='\e[33m'
BLUE='\e[34m'
WHITE='\e[37m'
BOLD='\e[1m'
UNDERLINE='\e[4m'
NC='\033[0m' # No Color


yes_no(){
  while :
      do
        read -r -n 1 select_number < /dev/tty
          case \${select_number} in
            1) return 0 ;;                              # Yes
            2) echo "スクリプトを終了します" > /dev/tty; return 1 ;;  # No
            *) echo "1 か 2 を入力してください" > /dev/tty ;;
          esac
    done
}

Verify(){
  echo
  echo "BPに表示されているairgap-set.tar.gzのハッシュを確認してください"
  hash_value=\$(sha256sum \${NODE_HOME}/airgap-set.tar.gz | awk '{print \$1}')
  echo -e "ハッシュ値：\${YELLOW}\${hash_value}\${NC}"
  echo
  echo "上記のハッシュ値をBPに表示されてるハッシュ値と照合してください"
  echo
  echo "[1] 一致する [2] 一致しない"

  if yes_no; then
      echo
      echo "\${script_title}処理を実行しますか？"
      echo "[1] はい [2] いいえ"

      if yes_no; then
          tar -xzf \${NODE_HOME}/airgap-set.tar.gz --exclude="airgap_script" -C \${NODE_HOME}
          if [ \$? -ne 0 ]; then
              echo -e "\${RED}airgap-set.tar.gzの解凍に失敗しました。\${NC}"
              rm \${NODE_HOME}/airgap_script
              exit 1
          fi
          return 0   # 正常終了で関数を抜ける
      else
          echo "処理をキャンセルしました。"
          exit 0
      fi
  else
      echo "再度BPからairgap-set.tar.gzをコピーしてください"
      sleep 2
      exit 1
  fi
}

case \$1 in
  "verify" )
    Verify
  ;;

  "*" )
    echo "不正な引数です"
    rm \${NODE_HOME}/airgap_script
    exit 0
  ;;
esac

#------------------------------------------


EOF
}


signing_tx_file(){
  case $1 in
    "pool_register" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} --signing-key-file ${COLDKEYS_DIR}/${COLD_SKEY_FILENAME} --signing-key-file \${NODE_HOME}/${STAKE_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
    "stake_address" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} --signing-key-file \${NODE_HOME}/${STAKE_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
    "payment_address" )
      sing_cli="cardano-cli conway transaction sign --tx-body-file \${NODE_HOME}/tx.raw --signing-key-file \${NODE_HOME}/${PAYMENT_SKEY_FILENAME} $NODE_NETWORK --out-file \${NODE_HOME}/tx.signed"
    ;;
  esac
  cat >> "${NODE_HOME}/airgap_script" <<'EOF'
echo
echo "tx.rawをデコードして処理内容を確認します"
decode_tmp=$(mktemp)
decode_log=$(mktemp)

if ! cardano-cli debug transaction view --tx-body-file ${NODE_HOME}/tx.raw > "${decode_tmp}" 2> "${decode_log}"; then
  echo -e "${RED}tx.rawのデコードに失敗しました${NC}"
  cat "${decode_log}"
  rm -f "${decode_log}" "${decode_tmp}"
  rm -f ${NODE_HOME}/airgap_script
  exit 1
fi
rm -f "${decode_log}"

if command -v jq >/dev/null 2>&1; then
  echo
  echo "------ tx.raw 主な項目 ------"
  if ! jq '{fee, certificates, withdrawals, outputs}' "${decode_tmp}"; then
    cat "${decode_tmp}"
  fi
  echo "--------------------------------"
else
  cat "${decode_tmp}"
fi

operation_label="処理内容: 判別できません"
destination_lines=""
fee_line=""
pool_deposit_line=""

if command -v jq >/dev/null 2>&1; then
  summary_json=$(jq -c '
    def lovelace_amount($value):
      if $value == null then 0
      elif ($value | type) == "number" then $value
      elif ($value | type) == "string" then
        ((match("[0-9]+")?.string) | tonumber // 0)
      elif ($value | type) == "object" then
        ($value.lovelace // $value.coin // $value.amount // ($value.ada?.lovelace) // ($value.contents? | lovelace_amount(.)) // 0)
      else 0
      end;

    def find_fee:
      (
        [ .. | objects | select(has("fee")) | lovelace_amount(.fee) ]
        | map(select(. != 0))
        | .[0]
      );

    def find_outputs:
      [ .. | objects
        | select((has("address") or has("addressShelley") or has("addressBech32")) and (has("value") or has("amount")))
        | {address: (.address // .addressShelley // .addressBech32 // .value.address // ""), lovelace: lovelace_amount(.value // .amount)}
      ]
      | map(select(.address != ""))
      | unique_by(.address + "|" + (.lovelace | tostring));

    def find_withdrawals:
      [ .. | objects
        | select(has("withdrawals"))
        | .withdrawals
        | (if type == "object" then
             (to_entries | map({address: .key, lovelace: lovelace_amount(.value // 0)}))
           elif type == "array" then
             (map({address: (.address // ""), lovelace: lovelace_amount(.amount // 0)}))
           else []
           end)
        | .[]
        | select(.address != "")
      ];

    def find_certificate:
      (
        [ .. | objects
          | if has("certificate") then .certificate
            elif has("certType") then .certType
            elif has("type") then .type
            elif (keys_unsorted | map(select(test("(?i)(stake|pool)"))) | length) > 0 then
              (keys_unsorted | map(select(test("(?i)(stake|pool)"))) | .[0])
            else empty
            end
          | tostring
          | select(test("(?i)(stake|pool)"))
        ]
      | .[0]);

    {
      fee: find_fee,
      outputs: find_outputs,
      withdrawals: find_withdrawals,
      certificate: find_certificate
    }
  ' "${decode_tmp}" 2>/dev/null)

  if [[ -n "${summary_json}" && "${summary_json}" != "null" ]]; then
    tx_fee=$(echo "${summary_json}" | jq -r '.fee // empty')
    certificate_name=$(echo "${summary_json}" | jq -r '.certificate // empty')
    withdrawal_count=$(echo "${summary_json}" | jq -r '.withdrawals | length // 0')
    outputs_count=$(echo "${summary_json}" | jq -r '.outputs | length // 0')
    payment_addr=""
    if [[ -f "${NODE_HOME}/${PAYMENT_ADDR_FILENAME}" ]]; then
      payment_addr=$(tr -d "\n" < "${NODE_HOME}/${PAYMENT_ADDR_FILENAME}")
    fi
    destination_lines=$(echo "${summary_json}" | jq -r --arg myaddr "${payment_addr}" '
      .outputs
      | map(select(.address != "" and (.address != $myaddr or $myaddr == "")))
      | map("送金先: \(.address)\n送金額: \(.lovelace) Lovelace\n")
      | .[]
    ' 2>/dev/null)

    if [[ -n "${tx_fee}" && "${tx_fee}" != "null" ]]; then
      fee_line="手数料: ${tx_fee} Lovelace"
    fi

    if [[ -n "${certificate_name}" && "${certificate_name}" != "null" ]]; then
      lower_cert=$(echo "${certificate_name}" | tr '[:upper:]' '[:lower:]')
      if [[ "${lower_cert}" == *"pool"* && "${lower_cert}" == *"reg"* ]]; then
        operation_label="処理内容: プール登録/情報変更"
      elif [[ "${lower_cert}" == *"pool"* && ( "${lower_cert}" == *"retire"* || "${lower_cert}" == *"retir"* ) ]]; then
        operation_label="処理内容: プールリタイア"
      elif [[ "${lower_cert}" == *"stake"* && "${lower_cert}" == *"dereg"* ]]; then
        operation_label="処理内容: ステークアドレス解除"
      elif [[ "${lower_cert}" == *"stake"* && "${lower_cert}" == *"reg"* ]]; then
        operation_label="処理内容: ステークアドレス登録"
      fi
    fi

    if [[ "${withdrawal_count}" -gt 0 ]]; then
      operation_label="処理内容: ステークアドレス出金"
      destination_lines=$(echo "${summary_json}" | jq -r '
        .withdrawals[]
        | "出金先(ステークアドレス): \(.address)\n出金額: \(.lovelace) Lovelace\n"
      ' 2>/dev/null)
    elif [[ -n "${destination_lines}" ]]; then
      operation_label="処理内容: payment.addr出金"
    elif [[ "${operation_label}" == "処理内容: 判別できません" && "${outputs_count}" -gt 1 ]]; then
      operation_label="処理内容: payment.addr出金"
    fi

    if [[ "${operation_label}" == "処理内容: プール登録/情報変更" ]]; then
      pool_deposit_value=""
      if [[ -f "${NODE_HOME}/params.json" ]]; then
        pool_deposit_value=$(jq -r '.stakePoolDeposit // empty' "${NODE_HOME}/params.json" 2>/dev/null)
      fi
      if [[ -n "${pool_deposit_value}" && "${pool_deposit_value}" =~ ^[0-9]+$ ]]; then
        pool_deposit_ada=$((pool_deposit_value / 1000000))
      else
        pool_deposit_ada=500
      fi
      pool_deposit_line="プール登録料: ${pool_deposit_ada} ADA"
    fi
  fi
fi

echo
echo "-------- トランザクション要約 --------"
echo "${operation_label}"
if [[ -n "${destination_lines}" ]]; then
  printf "%s\n" "${destination_lines}"
fi
if [[ -n "${fee_line}" ]]; then
  echo "${fee_line}"
fi
if [[ -n "${pool_deposit_line}" ]]; then
  echo "${pool_deposit_line}"
fi
echo "--------------------------------------"
echo
echo "この内容で署名しますか？ [1] はい [2] いいえ"

if ! yes_no; then
  echo "署名をキャンセルしました"
  rm -f "${decode_tmp}"
  rm -f ${NODE_HOME}/airgap_script
  exit 0
fi

rm -f "${decode_tmp}"
EOF
  cat >> "${NODE_HOME}/airgap_script" << EOF 
$sing_cli
echo
echo "トランザクション署名ファイルを生成しました(\${NODE_HOME}/tx.signed)"
echo
echo -e "\${GREEN}tx.signed\${NC}をBPの作業ディレクトリにコピーしてください"
hash_value=\$(sha256sum \${NODE_HOME}/tx.signed | awk '{print \$1}')
echo -e "ハッシュ値：\${YELLOW}\${hash_value}\${NC}"
echo
read -p "コピーしたらEnterを押して下さい" < /dev/tty
rm -f \${NODE_HOME}/airgap_script
EOF
chmod 755 ${NODE_HOME}/airgap_script
}


CreatePoolCert(){
  source ${env_path}
  local -a relayHosts relayPorts
  local existingRelayCount=0
  local key value idx
  local existingRelayAddress existingRelayPort
  local hasRelayPortEntries=0

  if [[ -f "${env_path}" ]]; then
    while IFS='=' read -r key value; do
      value=${value%$'\r'}
      if [[ $key =~ ^RELAY([0-9]+)_HOST$ ]]; then
        idx=${BASH_REMATCH[1]}
        relayHosts[$idx]="${value}"
      elif [[ $key =~ ^RELAY([0-9]+)_PORT$ ]]; then
        idx=${BASH_REMATCH[1]}
        relayPorts[$idx]="${value}"
        hasRelayPortEntries=1
      fi
    done < "${env_path}"

    for idx in "${!relayHosts[@]}"; do
      if [[ -n "${relayHosts[$idx]}" ]]; then
        ((existingRelayCount++))
      fi
    done
  fi

  local defaultRelayNum="${existingRelayCount}"
  if [[ ${hasRelayPortEntries} -eq 0 ]]; then
    defaultRelayNum="2"
  fi
  while :
  do
  inputPledge=$(gum input --width=0 --header="Pledge誓約ADAを整数で入力して下さい(例:10000)" --char-limit=7 --header.foreground="99" --no-show-help --placeholder "Pledge")
  if [[ "$inputPledge" =~ ^[0-9]+$ ]]; then
    if (( "$inputPledge" >= 1 )); then
      break 1
    else
      echo "1以上の数字を入力してください"
    fi
  else
    echo "数字を入力してください"
  fi
  done
  inputFixCost=$(gum input --value="170" --width=0 --header="固定手数料を整数で入力してください(170以上)" --char-limit=5 --header.foreground="99" --no-show-help --placeholder "Fix Cost")
  inputFixMargin=$(gum input --value="0.5" --width=0 --header="変動手数料率を入力してください(%不要)" --char-limit=3 --header.foreground="99" --no-show-help --placeholder "0.5 or 1.5 or 3 etc...")

  while :
  do
    inputRelayNum=$(gum input --value="${defaultRelayNum}" --width=0 --header="オンチェーンに登録するリレー数を入力してください" --char-limit=1 --header.foreground="99" --no-show-help --placeholder "Number Of Relay")
      # 入力が数字かどうかを確認
    if [[ "$inputRelayNum" =~ ^[0-9]+$ ]]; then
      # 配列を使用して変数を管理
      declare -a inputRelays=()
      declare -a inputPorts=()
      poolRelaySet=""

      # ループを実行
      for ((i = 1; i <= $inputRelayNum; i++)); do
        if [ "$i" -ge "2" ]; then poolRelaySet+="   "; fi
        
        

        while :
        do
          existingRelayAddress="${relayHosts[$i]}"
          inputRelayAddress=$(gum input --value="${existingRelayAddress}" --width=0 --header="リレー${i}のIPまたはDNSアドレスを入力してください" --char-limit=255 --header.foreground="99" --no-show-help --placeholder "IP Address or DNS Name")
          # 正規表現でIPv4アドレスの形式をチェック
          if [[ $inputRelayAddress =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
              # 各オクテットが0〜255の範囲内であることをチェック
              IFS='.' read -r -a octets <<< "$inputRelayAddress"
              valid=true
              for octet in "${octets[@]}"; do
                  if (( octet < 0 || octet > 255 )); then
                      valid=false
                      break
                  fi
              done
              if [ "$valid" = true ]; then
                  poolRelaySet+="--pool-relay-ipv4 ${inputRelayAddress}"
                  inputRelays[$i]=${inputRelayAddress}
                  break 1
              else
                  echo "無効なIPアドレスです"
              fi
          elif [[ $inputRelayAddress =~ ^([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]; then
              poolRelaySet+="--single-host-pool-relay ${inputRelayAddress}"
              inputRelays[$i]=${inputRelayAddress}
              break 1
          else
              echo "無効なIPアドレスまたはDNSアドレスです"
          fi
        done

        while :
        do
        existingRelayPort="${relayPorts[$i]}"
        inputRelayPort=$(gum input --value="${existingRelayPort}" --width=0 --header="リレー${i}のポート番号を入力してください" --char-limit=255 --header.foreground="99" --no-show-help --placeholder "Realy Port")
        if [[ "$inputRelayPort" =~ ^([0-9]{1,5})$ ]]; then
          if (( inputRelayPort >= 1 && inputRelayPort <= 65535 )); then
          poolRelaySet+="   --pool-relay-port ${inputRelayPort}"
          inputPorts[$i]=${inputRelayPort}
          break 1
          else
            echo "1から65535の間の数字を入力してください"
          fi
        else
            echo "入力のポート番号が無効な形式です"
        fi
        done
        


      done
      break 1
    else
      echo "数字を入力してください"
      exit 1
    fi
  done


  # ヘッダー行を出力
  echo -e "誓約(Pledge)" ${B_YELLOW}"${inputPledge}ADA"${NC} >> table.out
  echo -e "固定手数料" "${inputFixCost}ADA"  >> table.out
  echo -e "変動手数料" "${inputFixMargin}%" >> table.out
  echo -e "登録リレー数" "$inputRelayNum"  >> table.out

  for ((i = 1; i <= $inputRelayNum; i++)); do
    echo -e "リレー$iアドレス" "${inputRelays[$i]}"  >> table.out
    echo -e "リレー$iポート" "${inputPorts[$i]}"  >> table.out
  done
  echo -e "メタデータURL" "${POOL_METADATA_URL}"  >> table.out
  column -t < table.out
  rm table.out

  echo
  echo "pool.cert生成実行コマンド確認"
  echo "コマンド上の入力数字はLovelace形式です"
  cmdPoolCert=$(cat << EOF
  cardano-cli conway stake-pool registration-certificate \
    --cold-verification-key-file ${COLDKEYS_DIR}/${COLD_VKEY_FILENAME} \
    --vrf-verification-key-file \${NODE_HOME}/${VRF_VKEY_FILENAME} \
    --pool-pledge $(echo "${inputPledge}000000") \
    --pool-cost $(echo "${inputFixCost}000000") \
    --pool-margin $(echo 0)$(echo "scale=3; ${inputFixMargin} / 100" | bc) \
    --pool-reward-account-verification-key-file \${NODE_HOME}/${STAKE_VKEY_FILENAME} \
    --pool-owner-stake-verification-key-file \${NODE_HOME}/${STAKE_VKEY_FILENAME} \
    $NODE_NETWORK \
    $poolRelaySet \
    --metadata-url ${POOL_METADATA_URL} \
    --metadata-hash \$(cat \${NODE_HOME}/poolMetaDataHash.txt) \
    --out-file \${NODE_HOME}/${POOL_CERT_FILENAME}
EOF
)
  echo
  echo -e ${GRAY}"$cmdPoolCert"${NC} | sed 's/   / \\\n/g'
  echo
  Gum_Confirm_YesNo "この値で${POOL_CERT_FILENAME}を生成しますか？" "Yes" "再度入力してください"
  if [[ ${iniSettings} == "Yes" ]]; then
    script_discription=$(cat <<EOF
このスクリプトでは以下の処理が実行されます
1.プール登録証明書 \${GREEN}${POOL_CERT_FILENAME}\${NC} の作成
2.トランザクション署名ファイル \${GREEN}tx.signed\${NC} の作成
EOF
    )
    create_airgap_script "プール登録証明書作成" "${script_discription}"
    cat >> "${NODE_HOME}/airgap_script" << EOF
    echo
    chmod u+rwx ${COLDKEYS_DIR}
    $cmdPoolCert
    echo -e プール登録証明書 \${YELLOW}"\${NODE_HOME}/${POOL_CERT_FILENAME}\${NC} を生成しました"
EOF
    return
  else
    echo ${iniSettings}
    return 99
  fi

}
